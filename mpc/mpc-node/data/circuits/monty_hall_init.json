{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":1086328093816157943,"abi":{"parameters":[{"name":"seed","type":{"kind":"field"},"visibility":"private"},{"name":"seed_r","type":{"kind":"struct","path":"pss_utils::private_state::CommitMetaData","fields":[{"name":"data","type":{"kind":"array","length":1,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"seed_c","type":{"kind":"field"},"visibility":"public"},{"name":"out_r","type":{"kind":"struct","path":"pss_utils::private_state::CommitMetaData","fields":[{"name":"data","type":{"kind":"array","length":1,"type":{"kind":"field"}}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VY224aMRAdYBPCLeGea3O/p61sFsLyxq8Udfn/pz5W9ZYddRhcIrHHlTrSyBMvnByfmR0bl2hlX53f0KaV8nGej7F5H4/T6Si1sf1mRrNFMjHjyeI9sYmdJJPvoySO02ScTGeL2dTM7DhO7XIyi5dmZXsCyxQzG5Ln/u48Yz2Rces6jwTXTIefgjfHJRHv5zF/r+r8wHnNeV3Ms5WVBqaY2TJQzyqOl6GAeW8AefryLnPd+CDm7zWdt5wfOj/K5yOV822amGJmmxQmd4TkaY2RWrTzscOCVPIxe/BDzWUfOlCkKgFF3LVI02VmxrYJV/Ad3BpNRH+amDb0i9pe410MTfLthiScgW926WLIXWCR9oDrDaVhj3wdrhhyj7AdDr3uzl/WXRS3T9jdjhtqhpudUv7lLoVsZB66KOxYajHIxyELwgJmD6pqbugREn3kGxKuuI6BvKQOxx4d0Lt1h1C79TIdADUdUpgiRzeWk915LvTERz+f5NG5KeITWj9Gnzo/c37u/II2fz6ha6gFxDoF5uYThakhtH6HQKwzoH6X/4l+R0Csc6B+V4Q9dOjekNU394BLEV+J+ILWe8M1ra6/bp3fUfirlWugnvdAXhSwHoF7l70B6vdAYevxXtTdg4hvRXyn6vHR+ZPzZ+cvFH6vqgCxnoC5eaWwuXkUOXgV8bOIX1Ru3px/dv6FVtfmoXtFBNTzjbB6RqoeWVc+q7MeHEcenfjmrZaPdYUzx/AdMX4jDP7vK25tdRE31LOyRxMS3Hx/l9W47bPbbuFanmeM2ctHyZfXUVPjQOAiewjj98Pge3M1EHFfrVPqPQdxYDx+d/Zo08rqGX9WvzMlPD+ruVQ8/4uNa6Yv5ljPX4FtUDBjHAAA","debug_symbols":"7ZndisIwEEbfJddeZGbyN32VZZGqVQqllVoXFtl33yqmlt2iF5q4i7lrmq+HyYGQaXsQq2Kx38zLet3sRPZ2EFWzzLuyqfvRQcjTrd02r4+jXZe3nchQqZko6pXICOBrJtZlVYjM9Je/oqDBnrOg9SjME2HUxoNRs7oeBknsydLZS1hPhEmbc1ahHKI4FUULnouW6HoYrPVgsKxvhCVcKjZuHH6fCUimI5nGZDqSabrXtJHa0w3xWF5PV1N0IvR0Tdfpblin44tAgxNRpXwdinGIWnksQ/+NMswDy3DjMnq2Dch2AdkckA0yJBxCwjEknELCVUj44zYyS/wJNyHhNiTchYRzQDjKkPDJHaqk7wwUuRtnG9nhbCPm/9BFIHt1SPJWY0CAw/II7urXMKmOpZqS6liqVVIdS7VOqmOpNkl1LNU2qY6l2iXVsVRzUh1JNcnXU/2sD6Ev+Lb4FNX9YNGWVVVu5uP/WP3tj7wt80VVnIfrfb0czXafWz/jn9+2zbJY7dviSDrN9fhv","file_map":{"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"61":{"source":"use monty_hall::game_state::GameState;\nuse pss_utils::private_state::{CommitMetaData, PrivateState};\n\nfn main(\n    seed: Field,\n    seed_r: CommitMetaData<1>,\n    seed_c: pub Field,\n    out_r: CommitMetaData<1>,\n) -> pub Field {\n    let seed = PrivateState::from_data_and_commitment(seed, seed_r, seed_c).verify();\n\n    let state = GameState::init(seed);\n\n    // TODO how to open the data to the users?\n    PrivateState::new(state, out_r).commitment\n}\n","path":"/home/fnieddu/repos/monty-hall-aztec/noir_logic/monty_hall_init/src/main.nr"},"62":{"source":"use pss_utils::{private_state::PrivateStateTrait, prng::Prng};\n\nglobal STATE_INITIALIZED: Field = 0;\nglobal STATE_OPENED_DOOR: Field = 1;\n\npub struct GameState {\n    pub(crate) state: Field,\n    pub(crate) prng: Prng,\n    pub(crate) winning_door: u8,\n    pub(crate) chosen_door: u8,\n    pub(crate) open_door: u8,\n}\n\nimpl PrivateStateTrait for GameState {\n    let N: u32 = 9;\n\n    fn as_field_array(self) -> [Field; Self::N] {\n        let prng = self.prng.as_field_array();\n        [\n            self.state,\n            prng[0],\n            prng[1],\n            prng[2],\n            prng[3],\n            prng[4],\n            self.winning_door as Field,\n            self.chosen_door as Field,\n            self.open_door as Field,\n        ]\n    }\n}\n\nimpl GameState {\n    pub fn init(seed: Field) -> GameState {\n        let mut prng = Prng::init(seed);\n        let winning_door = prng.get_field() as u8 % 3;\n        // println(f\"Winning door: {winning_door}\");\n\n        let state = GameState {\n            state: STATE_INITIALIZED,\n            prng,\n            winning_door,\n            chosen_door: 0,\n            open_door: 0,\n        };\n\n        state\n    }\n\n    // Returns the opened door and the new game state\n    pub fn choose_door(mut state: Self, door: u8) -> (GameState, u8) {\n        assert(state.state == STATE_INITIALIZED);\n        assert(door < 3);\n        state.chosen_door = door;\n\n        // We try avoiding nested if-else statements since we do not support them yet.\n        let calc_if_equal = {\n            // Winning door == chosen door\n            let rand = state.prng.get_field();\n            let opened = rand as bool;\n            let opened = opened as u8;\n            let opened = if state.winning_door == 0 {\n                opened + 1\n            } else {\n                opened\n            };\n            let opened = if state.winning_door == 1 {\n                (opened + 1) % 3\n            } else {\n                opened\n            };\n            opened\n        };\n\n        let calc_if_not_equal = {\n            // Winning door != chosen door\n            3 - state.winning_door - door // 0, 1 -> 2; 0, 2 -> 1; 1, 2 -> 0\n        };\n\n        state.open_door = if state.winning_door == door {\n            calc_if_equal\n        } else {\n            calc_if_not_equal\n        };\n        state.state = STATE_OPENED_DOOR;\n        let open_door = state.open_door;\n\n        (state, open_door)\n    }\n\n    // Returns whether the player won or not\n    pub fn switch(state: Self, switch: bool) -> bool {\n        assert(state.state == STATE_OPENED_DOOR);\n\n        let user_door = if switch {\n            3 - state.chosen_door - state.open_door // 0, 1 -> 2; 0, 2 -> 1; 1, 2 -> 0\n        } else {\n            state.chosen_door\n        };\n        user_door == state.winning_door\n    }\n}\n\n#[test]\nfn test_win_no_switch() {\n    let seed = 123;\n    let choice = 0;\n    let switch = false;\n\n    let mut game = GameState::init(seed); // Winning door is 0\n    let (game, opened) = GameState::choose_door(game, choice);\n    assert(opened != 0);\n    assert(GameState::switch(game, switch));\n}\n\n#[test]\nfn test_win_switch1() {\n    let seed = 123;\n    let choice = 1;\n    let switch = true;\n\n    let mut game = GameState::init(seed); // Winning door is 0\n    let (game, opened) = GameState::choose_door(game, choice);\n    assert(opened == 2);\n    assert(GameState::switch(game, switch));\n}\n\n#[test]\nfn test_win_switch2() {\n    let seed = 123;\n    let choice = 2;\n    let switch = true;\n\n    let mut game = GameState::init(seed); // Winning door is 0\n    let (game, opened) = GameState::choose_door(game, choice);\n    assert(opened == 1);\n    assert(GameState::switch(game, switch));\n}\n\n#[test]\nfn test_lose_no_switch1() {\n    let seed = 123;\n    let choice = 1;\n    let switch = false;\n\n    let game = GameState::init(seed); // Winning door is 0\n    let (game, opened) = GameState::choose_door(game, choice);\n    assert(opened == 2);\n    assert(!GameState::switch(game, switch));\n}\n\n#[test]\nfn test_lose_no_switch2() {\n    let seed = 123;\n    let choice = 2;\n    let switch = false;\n\n    let mut game = GameState::init(seed); // Winning door is 0\n    let (game, opened) = GameState::choose_door(game, choice);\n    assert(opened == 1);\n    assert(!GameState::switch(game, switch));\n}\n\n#[test]\nfn test_lose_switch() {\n    let seed = 123;\n    let choice = 0;\n    let switch = true;\n\n    let mut game = GameState::init(seed); // Winning door is 0\n    let (game, opened) = GameState::choose_door(game, choice);\n    assert(opened != 0);\n    assert(!GameState::switch(game, switch));\n}\n","path":"/home/fnieddu/repos/monty-hall-aztec/noir_logic/monty_hall/src/game_state.nr"},"65":{"source":"// Follows the SAFE API [https://eprint.iacr.org/2023/522.pdf](https://eprint.iacr.org/2023/522.pdf)\n// It is not used in the Aztec infrastructure\npub struct Commit {}\n\nimpl Commit {\n    fn absorb(data: Field, state: &mut [Field; 4], position: &mut Field) {\n        if *position == 3 {\n            *state = std::hash::poseidon2_permutation(*state, 4);\n            *position = 0;\n        }\n        state[*position] += data;\n        *position += 1;\n    }\n\n    pub(crate) fn commit_field_array<let N: u32>(data: [Field; N]) -> Field {\n        let d = 0x4142;\n        let absorb = 0x80000000 + N as Field;\n        let squeeze = 1;\n        let t = d + squeeze * 65536 + absorb * 281474976710656;\n        let mut state = [0, 0, 0, t];\n        let mut position = 0;\n\n        // Absorb\n        for i in 0..N {\n            Self::absorb(data[i], &mut state, &mut position);\n        }\n\n        // Squeeze\n        std::hash::poseidon2_permutation(state, 4)[0]\n    }\n\n    pub(crate) fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n        std::hash::poseidon2::Poseidon2::hash(inputs, N)\n    }\n}\n","path":"/home/fnieddu/repos/monty-hall-aztec/noir_logic/pss_utils/src/commit.nr"},"69":{"source":"use super::{commit::Commit, dh};\nuse std::embedded_curve_ops::EmbeddedCurvePoint;\n\nfn array_concat<T, let N: u32, let M: u32>(\n    separator: T,\n    array1: [T; N],\n    array2: [T; M],\n) -> [T; N + M + 1] {\n    let mut result = [separator; N + M + 1];\n    for i in 0..N {\n        result[i + 1] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N + 1] = array2[i];\n    }\n    result\n}\n\n// In the Aztec infrastrucutre it is the owners address and the storage slot, i.e., [owner, storage_slot]\n// The MPC network however only adds a random value alongside the data, since we do not have the concept of storage slots\npub struct CommitMetaData<let N: u32> {\n    pub(crate) data: [Field; N],\n}\n\npub struct PrivateState<D, let N: u32> {\n    pub(crate) data: D,\n    pub(crate) meta: CommitMetaData<N>,\n    pub commitment: Field,\n}\n\npub trait PrivateStateTrait {\n    let N: u32;\n\n    fn as_field_array(self) -> [Field; Self::N];\n}\n\nimpl<D, let N: u32> PrivateState<D, N>\nwhere\n    D: PrivateStateTrait,\n{\n\n    // Required to have commitments as public inputs to the main function\n    pub fn from_data_and_commitment(\n        data: D,\n        meta: CommitMetaData<N>,\n        commitment: Field,\n    ) -> PrivateState<D, N> {\n        PrivateState { data, meta, commitment }\n    }\n\n    pub fn new(data: D, meta: CommitMetaData<N>) -> PrivateState<D, N> {\n        let commitment = Self::commit(data, meta);\n        PrivateState { data, meta, commitment }\n    }\n\n    pub fn verify(self) -> D {\n        let calc_commitment = Self::commit(self.data, self.meta);\n        // println(calc_commitment);\n        assert(self.commitment == calc_commitment);\n        self.data\n    }\n\n    // Returns the data and the nullifier\n    pub fn verify_and_nullify(\n        self,\n        secret_key: Field,\n        public_key: EmbeddedCurvePoint,\n    ) -> (D, Field) {\n        let data = self.verify();\n        let nullifier = PrivateState::<D, N>::compute_nullifier(self.commitment, secret_key);\n        let (_, pk) = dh::generate_ephemeral_key_pair(secret_key);\n        assert(pk == public_key);\n\n        (data, nullifier)\n    }\n\n    // Aztec compatible: [https://docs.aztec.network/aztec/smart_contracts/functions/attributes#implementing-notes](https://docs.aztec.network/aztec/smart_contracts/functions/attributes#implementing-notes)\n    pub fn commit(data: D, meta: CommitMetaData<N>) -> Field {\n        let GENERATOR_INDEX__NOTE_HASH: u32 = 1;\n\n        let data = data.as_field_array();\n        let packed = array_concat(GENERATOR_INDEX__NOTE_HASH as Field, data, meta.data);\n        Commit::poseidon2_hash(packed)\n    }\n\n    // Aztec compatible: [https://docs.aztec.network/aztec/smart_contracts/functions/attributes#implementing-notes](https://docs.aztec.network/aztec/smart_contracts/functions/attributes#implementing-notes)\n    pub fn compute_nullifier(commitment: Field, secret_key: Field) -> Field {\n        let GENERATOR_INDEX__NOTE_NULLIFIER: u32 = 53;\n\n        let packed = [GENERATOR_INDEX__NOTE_NULLIFIER as Field, commitment, secret_key];\n        Commit::poseidon2_hash(packed)\n    }\n}\n\nimpl PrivateStateTrait for Field {\n    let N: u32 = 1;\n\n    fn as_field_array(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl PrivateStateTrait for u8 {\n    let N: u32 = 1;\n\n    fn as_field_array(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl PrivateStateTrait for bool {\n    let N: u32 = 1;\n\n    fn as_field_array(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n","path":"/home/fnieddu/repos/monty-hall-aztec/noir_logic/pss_utils/src/private_state.nr"},"70":{"source":"use super::private_state::PrivateStateTrait;\n\n// Follows the SAFE API [https://eprint.iacr.org/2023/522.pdf](https://eprint.iacr.org/2023/522.pdf)\npub struct Prng {\n    pub(crate) state: [Field; 4],\n    pub(crate) position: Field,\n}\n\nimpl Prng {\n    pub fn init(seed: Field) -> Prng {\n        Prng { state: [seed, 0, 0, 0], position: 3 }\n    }\n\n    pub fn get_field(&mut self) -> Field {\n        if self.position == 3 {\n            self.state = std::hash::poseidon2_permutation(self.state, 4);\n            self.position = 0;\n        }\n        let result = self.state[self.position];\n        self.position += 1;\n        result\n    }\n}\n\nimpl PrivateStateTrait for Prng {\n    let N: u32 = 5;\n\n    fn as_field_array(self) -> [Field; Self::N] {\n        [self.state[0], self.state[1], self.state[2], self.state[3], self.position]\n    }\n}\n","path":"/home/fnieddu/repos/monty-hall-aztec/noir_logic/pss_utils/src/prng.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}