{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":15755733959890704745,"abi":{"parameters":[{"name":"seed","type":{"kind":"field"},"visibility":"private"},{"name":"seed_r","type":{"kind":"field"},"visibility":"private"},{"name":"seed_c","type":{"kind":"field"},"visibility":"public"},{"name":"out_r","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/71Y23LiMAwVEEqBUiglvW7v9919iElSkjd+ZZkN//+0jzvrLNZUiLSdIcfVjMaKHQ7ykSw7btBKflq9ok1puHbu2jh6TZJiNi1MbH5F03yRpVGSLl4zk5k0S39PszgusiSb5Yt8FuUmiQuzTPN4Ga2kLbCimuLTz50t/cxWjXGPJjHJtPRtbDVQvv51dkPYbWHvOJt/17G6a7VrtSf6WZqKg6iemCaQzw7Or+gzPtuf2Py7vtU9qwOr+64/UFxKaYD57ZOftUBIP20mSy6Grh0xIS3XlgN/VF/50q5yquWRxG2TtFiWEpkh4RJ+hJtjFNBbodCCLnzDNb/roUl/D3w6XIJvVr96yAfAJB0D5+uLwzFVVbh6yGPCVjj0vEfvzLsu7iFhdzsuqCVuuft/5S6FLGQV7qKwY8nFxLUhE8IElgMd1RdWEIk+SoWES64joF+Sh6MKHtC79YhQu/WymAA5DclPkqMLy/GWfrrPktw9vvtZIo/LfWHvCfuY1o/RJ1ZPrZ5ZPafNzxJ0Dg2AWCfA2HwjPzmE5m8fiHUK5O/CE3/oWn4GnPMlYWu5Xs9lTvK6vRD2pbDPaX09l9dA11ZvrN6S//UMrL3mChibO8Ie4nRs7kQMroV9I+xbFZt7qw9WH60+fUFsWkCse2BsnslvbJ5FDB6E/SjsJxWbF6vfrf6g1XWq7+u5AMjnC2H5DFQ+Mq981mQ+2A4qeOKbo65rewpnjvF3yvh9P/j/rz619ITdV2PNCk5I+Fb13FTtR+9+dIs0qBhjzEPXSn95Hl3VhgIXWUMYf+IHvzJWobAnap6S7znIB8bjtdOmTWmqMX5Xr5kG3j9DSloV/8XCOTMRfcznP9uIiZN7GgAA","debug_symbols":"3ZjJioQwFEX/JWsXZjCDv9I0hUMsAqLi0NBI/XvHwnSFKrEX7YMyO2OOh3sX8aEzKnU+XS+mqdoBpR8zqtsiG03b2NWM4vutocuaZTWMWT+iFEsWId2UKCUJvkWoMrVGKbeXL6iQfEUliR8o30AVUyuqFPkDxcKhiXqg9PYZIXy6xOR0iel/E3Oxndi62ZabCOLciu67WZysKMNebraFYupQ7sUQS4zkuBhE+DGsmwO6BaBbAroVoBvHkHIMKSeQcgopP/AcU/wsTyDlHFIuIOUSUq4A5WTzhFLmxgQVcl/OWbyifHnVHzQDhWC/c4r4M/AVJRy7rDF7HvA46HYk6HY06HYs6HZJ0O140O1E0O3kW7bb/UpVJ4tsF3lv6tpcL/4vDXv7K+tNltd6XVZTU3i743fndtzzXd8Wupx6vZjue1b/Aw==","file_map":{"61":{"source":"use monty_hall::game_state::GameState;\nuse monty_hall::private_state::PrivateState;\n\nfn main(seed: Field, seed_r: Field, seed_c: pub Field, out_r: Field) -> pub Field {\n    let seed = PrivateState::from_data_and_commitment(seed, seed_r, seed_c).verify();\n\n    let state = GameState::init(seed);\n\n    // TODO how to open the data to the users?\n    PrivateState::new(state, out_r).commitment\n}\n","path":"/home/fnieddu/repos/monty-hall-aztec/noir_logic/monty_hall_init/src/main.nr"},"63":{"source":"// Follows the SAFE API [https://eprint.iacr.org/2023/522.pdf](https://eprint.iacr.org/2023/522.pdf)\npub struct Commit {}\n\nimpl Commit {\n    fn absorb(data: Field, state: &mut [Field; 4], position: &mut Field) {\n        if *position == 3 {\n            *state = std::hash::poseidon2_permutation(*state, 4);\n            *position = 0;\n        }\n        state[*position] += data;\n        *position += 1;\n    }\n\n    pub fn commit_field_array<let N: u32>(data: [Field; N], rand: Field) -> Field {\n        let d = 0x4142;\n        let absorb = 0x80000000 + N as Field;\n        let squeeze = 1;\n        let t = d + squeeze * 65536 + absorb * 281474976710656;\n        let mut state = [0, 0, 0, t];\n        let mut position = 0;\n\n        // Absorb\n        for i in 0..N {\n            Self::absorb(data[i], &mut state, &mut position);\n        }\n        Self::absorb(rand, &mut state, &mut position);\n\n        // Squeeze\n        std::hash::poseidon2_permutation(state, 4)[0]\n    }\n}\n","path":"/home/fnieddu/repos/monty-hall-aztec/noir_logic/monty_hall/src/commit.nr"},"64":{"source":"use super::prng::Prng;\n\nglobal STATE_INITIALIZED: Field = 0;\nglobal STATE_OPENED_DOOR: Field = 1;\n\npub struct GameState {\n    pub(crate) state: Field,\n    pub(crate) prng: Prng,\n    pub(crate) winning_door: u8,\n    pub(crate) chosen_door: u8,\n    pub(crate) open_door: u8,\n}\n\nimpl GameState {\n    pub fn init(seed: Field) -> GameState {\n        let mut prng = Prng::init(seed);\n        let winning_door = prng.get_field() as u8 % 3;\n        // println(f\"Winning door: {winning_door}\");\n\n        let state = GameState {\n            state: STATE_INITIALIZED,\n            prng,\n            winning_door,\n            chosen_door: 0,\n            open_door: 0,\n        };\n\n        state\n    }\n\n    // Returns the opened door and the new game state\n    pub fn choose_door(mut state: Self, door: u8) -> (GameState, u8) {\n        assert(state.state == STATE_INITIALIZED);\n        assert(door < 3);\n        state.chosen_door = door;\n\n        // We try avoiding nested if-else statements since we do not support them yet.\n        let calc_if_equal = {\n            // Winning door == chosen door\n            let rand = state.prng.get_field();\n            let opened = rand as bool;\n            let opened = opened as u8;\n            let opened = if state.winning_door == 0 {\n                opened + 1\n            } else {\n                opened\n            };\n            let opened = if state.winning_door == 1 {\n                (opened + 1) % 3\n            } else {\n                opened\n            };\n            opened\n        };\n\n        let calc_if_not_equal = {\n            // Winning door != chosen door\n            3 - state.winning_door - door // 0, 1 -> 2; 0, 2 -> 1; 1, 2 -> 0\n        };\n\n        state.open_door = if state.winning_door == door {\n            calc_if_equal\n        } else {\n            calc_if_not_equal\n        };\n        state.state = STATE_OPENED_DOOR;\n        let open_door = state.open_door;\n\n        (state, open_door)\n    }\n\n    // Returns whether the player won or not\n    pub fn switch(state: Self, switch: bool) -> bool {\n        assert(state.state == STATE_OPENED_DOOR);\n\n        let user_door = if switch {\n            3 - state.chosen_door - state.open_door // 0, 1 -> 2; 0, 2 -> 1; 1, 2 -> 0\n        } else {\n            state.chosen_door\n        };\n        user_door == state.winning_door\n    }\n}\n\n#[test]\nfn test_win_no_switch() {\n    let seed = 123;\n    let choice = 0;\n    let switch = false;\n\n    let mut game = GameState::init(seed); // Winning door is 0\n    let (game, opened) = GameState::choose_door(game, choice);\n    assert(opened != 0);\n    assert(GameState::switch(game, switch));\n}\n\n#[test]\nfn test_win_switch1() {\n    let seed = 123;\n    let choice = 1;\n    let switch = true;\n\n    let mut game = GameState::init(seed); // Winning door is 0\n    let (game, opened) = GameState::choose_door(game, choice);\n    assert(opened == 2);\n    assert(GameState::switch(game, switch));\n}\n\n#[test]\nfn test_win_switch2() {\n    let seed = 123;\n    let choice = 2;\n    let switch = true;\n\n    let mut game = GameState::init(seed); // Winning door is 0\n    let (game, opened) = GameState::choose_door(game, choice);\n    assert(opened == 1);\n    assert(GameState::switch(game, switch));\n}\n\n#[test]\nfn test_lose_no_switch1() {\n    let seed = 123;\n    let choice = 1;\n    let switch = false;\n\n    let game = GameState::init(seed); // Winning door is 0\n    let (game, opened) = GameState::choose_door(game, choice);\n    assert(opened == 2);\n    assert(!GameState::switch(game, switch));\n}\n\n#[test]\nfn test_lose_no_switch2() {\n    let seed = 123;\n    let choice = 2;\n    let switch = false;\n\n    let mut game = GameState::init(seed); // Winning door is 0\n    let (game, opened) = GameState::choose_door(game, choice);\n    assert(opened == 1);\n    assert(!GameState::switch(game, switch));\n}\n\n#[test]\nfn test_lose_switch() {\n    let seed = 123;\n    let choice = 0;\n    let switch = true;\n\n    let mut game = GameState::init(seed); // Winning door is 0\n    let (game, opened) = GameState::choose_door(game, choice);\n    assert(opened != 0);\n    assert(!GameState::switch(game, switch));\n}\n","path":"/home/fnieddu/repos/monty-hall-aztec/noir_logic/monty_hall/src/game_state.nr"},"66":{"source":"use super::commit::Commit;\nuse super::game_state::GameState;\n\npub struct PrivateState<D> {\n    pub(crate) data: D,\n    pub(crate) rand: Field,\n    pub commitment: Field,\n}\n\npub trait PrivateStateTrait {\n    let N: u32;\n\n    fn as_field_array(self) -> [Field; Self::N];\n}\n\nimpl<D> PrivateState<D>\nwhere\n    D: PrivateStateTrait,\n{\n    // Required to have commitments as public inputs to the main function\n    pub fn from_data_and_commitment(data: D, rand: Field, commitment: Field) -> PrivateState<D> {\n        PrivateState { data, rand, commitment }\n    }\n\n    pub fn new(data: D, rand: Field) -> PrivateState<D> {\n        let commitment = Self::commit(data, rand);\n        PrivateState { data, rand, commitment }\n    }\n\n    pub fn verify(self) -> D {\n        assert(self.commitment == Self::commit(self.data, self.rand));\n        self.data\n    }\n\n    pub fn commit(data: D, rand: Field) -> Field {\n        let data = data.as_field_array();\n        Commit::commit_field_array::<_>(data, rand)\n    }\n}\n\nimpl PrivateStateTrait for Field {\n    let N: u32 = 1;\n\n    fn as_field_array(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl PrivateStateTrait for u8 {\n    let N: u32 = 1;\n\n    fn as_field_array(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl PrivateStateTrait for bool {\n    let N: u32 = 1;\n\n    fn as_field_array(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl PrivateStateTrait for GameState {\n    let N: u32 = 9;\n\n    fn as_field_array(self) -> [Field; Self::N] {\n        [\n            self.state,\n            self.prng.state[0],\n            self.prng.state[1],\n            self.prng.state[2],\n            self.prng.state[3],\n            self.prng.position,\n            self.winning_door as Field,\n            self.chosen_door as Field,\n            self.open_door as Field,\n        ]\n    }\n}\n","path":"/home/fnieddu/repos/monty-hall-aztec/noir_logic/monty_hall/src/private_state.nr"},"67":{"source":"// Follows the SAFE API [https://eprint.iacr.org/2023/522.pdf](https://eprint.iacr.org/2023/522.pdf)\npub struct Prng {\n    pub(crate) state: [Field; 4],\n    pub(crate) position: Field,\n}\n\nimpl Prng {\n    pub(crate) fn init(seed: Field) -> Prng {\n        Prng { state: [seed, 0, 0, 0], position: 3 }\n    }\n\n    pub(crate) fn get_field(&mut self) -> Field {\n        if self.position == 3 {\n            self.state = std::hash::poseidon2_permutation(self.state, 4);\n            self.position = 0;\n        }\n        let result = self.state[self.position];\n        self.position += 1;\n        result\n    }\n}\n","path":"/home/fnieddu/repos/monty-hall-aztec/noir_logic/monty_hall/src/prng.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}